## 动态规划问题


#### 动态规划定义
以下是《Introduction to algorithms》对动态规划的定义：
> A dynamic-programming algorithm solves each subsubproblem just once and then saves its answer in a table, thereby avoiding the work of recomputing the answer every time it solves each subsubproblem.

动态规划算法解决每一个子问题，仅一次，然后保存子问题的结果到内存表中，以此来避免对子问题的重复计算。

#### 例题1：爬楼梯
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

**Example1:**
> Input: 2
> Output: 2
> Explanation: There are two ways to climb to the top.
> 1. 1 step + 1 step
> 2. 2 steps

**Example2:**
> Input: 3
> Output: 3
> Explanation: There are three ways to climb to the top.
> 1. 1 step + 1 step + 1 step2. 
> 1 step + 2 steps
> 3. 2 steps + 1 step

这个问题的最优解可以构建为通过子问题来求解。

到达第i层楼可以有两种方法：
1. 从第i-1层楼爬一步到
2. 从第i-2层楼爬两部到

如果用s[i]表示到达第i层楼的所有方法，它进一步等于s[i-1] + s[i-2]。

java实现代码如下：
```java
class Solution {
    public int climbStairs(int n) {
        // 动态规划
        if(n <= 0){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        
        int oneStepBefore = 2;
        int twoStepBefore = 1;
        int allWay = 0;
        
        for(int i = 2; i < n; i ++){
            allWay = oneStepBefore + twoStepBefore;
            twoStepBefore = oneStepBefore;
            oneStepBefore = allWay;
        }
        
        return allWay;
    }
}
```

#### 例题2：最大子序列和
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

**Example:**
> Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.

最大连续子序列和只能以0~n-1中某个位置结束，当遍历到第i个元素时，判断它前面的连续子序列和是否大于0，如果大于0，则以当前位置i结尾的最大连续子序列和为它们两者之和，否则，以当前位置i结尾的最大连续子序列和元素i。

<center>maxSoFar = nums[i] + (maxSoFar > 0 ? maxSoFar : 0)</center>
```java
class Solution {
    public int maxSubArray(int[] nums) {
        
        int maxSoFar = nums[0];
        int maxTotal = maxSoFar;
        for(int i = 1; i < nums.length; i++){
            maxSoFar = nums[i] + (maxSoFar > 0 ? maxSoFar : 0);
            maxTotal = Math.max(maxTotal, maxSoFar);
        }
        return maxTotal;
    }
}
```

参考：
https://zhuanlan.zhihu.com/p/30754890
https://blog.csdn.net/sgbfblog/article/details/8032464